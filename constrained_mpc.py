import rtde_control
import rtde_receive
import time
import math
from std_msgs.msg import String
from copy import deepcopy
from planner import trajectPlanner, rtde_kinematic
UR_IP = "192.168.131.40"
dt = 0.008
dv_max = 0.024

def v_from_theta(theta_0, theta, v_0):  
    global dt
    v = []
    for i in range ( len(v_0) ):
        v_i = 2*(theta[i] - theta_0[i])/dt - v_0[i]
        v.append(v_i)
    return(v)

def theta_from_v(theta_0, v_0, v):
    global dt
    theta = []
    for i in range ( len(theta_0) ):
        theta_i = theta_0[i] + 0.5*(v_0[i] + v[i])*dt
        theta.append(theta_i)
    return(theta)

def smooth_v(v_0, begin_smooth):
    v = []
    v_i = []
    for i in range(begin_smooth):        
        v.append(deepcopy(v_0[i]))
    #n = len(v_0)-1
    for i in range(begin_smooth, n-begin_smooth):
        v_i = []
        for j in range(6):
            v_ij = 0.25*v_0[i-1][j] + 0.5*v_0[i][j] + 0.25*v_0[i+1][j]
            v_i.append(deepcopy(v_ij))
        v.append(deepcopy(v_i))
    for i in range(n-begin_smooth, n):
        v_i = []
        for j in range(6):
            v_ij = v_0[n-i][j]
            v_i.append(deepcopy(v_ij))
        v.append(deepcopy(v_i))    
    return(v)

def check_constraints(v, v_max):
    #flag1 = True
    #key_dim = 0
    key_gain = 1
    for i in range(6):
        if ( abs(v[i]) > v_max[i] ):
            #flag1 = False
            gain = v_max[i] / abs(v[i])
            if ( gain < key_gain ):
                key_gain = deepcopy(gain)
    return(key_gain)


if __name__ == '__main__':
    start = time.time()
    rtde_c = rtde_control.RTDEControlInterface(UR_IP)
    rtde_r = rtde_receive.RTDEReceiveInterface(UR_IP)
    print(rtde_r.getActualQ())
    #hardcoded 2 points
    point1 = [0.11692690627603683, -0.2022483796446109, 0.3460851994453057, -0.04457573381461219, 2.3162355051109698, -2.1024363321943977]
    point2 =  [0.11692690627603683, -0.2022483796446109, 0.36, -0.04457573381461219, 2.3162355051109698, -2.1024363321943977]
    #rtde_c.moveJ([1.611193299293518, -2.631559197102682, 2.146669864654541, -2.558228317891256, -1.5793679396258753, -0.031464401875631154], speed=0.05)
    
    tp = trajectPlanner(debug=False)
    cart_a = tp.a_PointToPoint(point1, point2)

    ik = rtde_kinematic(rtde_c, debug=False)
    theta_tar = ik.get_joint_pose(cart_a, rtde_r.getActualQ())
    
    # hardcoded joint trajectory
    # theta_tar = [ [ 2.7581, 0.95134, -2.6275, -1.4654, -0.38351, -1.5708 ],  
    #     [ 2.7567, 0.95056, -2.6272, -1.4649, -0.38488, -1.5708 ],  
    #     [ 2.7526, 0.94824, -2.6263, -1.4636, -0.38894, -1.5708 ],  
    #     [ 2.7461, 0.94447, -2.6247, -1.4614, -0.39553, -1.5708 ],  
    #     [ 2.7372, 0.93939, -2.6225, -1.4584, -0.40442, -1.5708 ],  
    #     [ 2.7262, 0.93312, -2.6198, -1.4549, -0.41539, -1.5708 ],  
    #     [ 2.7134, 0.9258, -2.6165, -1.4509, -0.42817, -1.5708 ], 
    #     [ 2.6991, 0.91759, -2.6126, -1.4466, -0.4425, -1.5708 ],  
    #     [ 2.6835, 0.90863, -2.6082, -1.4421, -0.45812, -1.5708 ],  
    #     [ 2.6668, 0.89905, -2.6032, -1.4374, -0.4748, -1.5708 ],  
    #     [ 2.6493, 0.88896, -2.5977, -1.4328, -0.49232, -1.5708 ],  
    #     [ 2.6311, 0.87847, -2.5918, -1.4283, -0.5105, -1.5708 ],  
    #     [ 2.6124, 0.86766, -2.5853, -1.4239, -0.52916, -1.5708 ],  
    #     [ 2.5934, 0.85662, -2.5784, -1.4198, -0.54816, -1.5708 ],  
    #     [ 2.5742, 0.84542, -2.571, -1.416, -0.56736, -1.5708 ],  
    #     [ 2.5549, 0.83409, -2.5632, -1.4125, -0.58666, -1.5708 ],  
    #     [ 2.5356, 0.8227, -2.5549, -1.4094, -0.60597, -1.5708 ],  
    #     [ 2.5164, 0.81128, -2.5462, -1.4067, -0.6252, -1.5708 ],  
    #     [ 2.4973, 0.79985, -2.5371, -1.4043, -0.64429, -1.5708 ],  
    #     [ 2.4784, 0.78844, -2.5276, -1.4024, -0.66318, -1.5708 ],  
    #     [ 2.4598, 0.77707, -2.5178, -1.4009, -0.68182, -1.5708 ],  
    #     [ 2.4414, 0.76576, -2.5075, -1.3998, -0.70018, -1.5708 ],  
    #     [ 2.4234, 0.75451, -2.4969, -1.3992, -0.71823, -1.5708 ],  
    #     [ 2.4057, 0.74333, -2.486, -1.3989, -0.73594, -1.5708 ],  
    #     [ 2.3883, 0.73223, -2.4748, -1.3991, -0.75328, -1.5708 ],  
    #     [ 2.3713, 0.72122, -2.4632, -1.3996, -0.77025, -1.5708 ],  
    #     [ 2.3548, 0.71028, -2.4513, -1.4006, -0.78683, -1.5708 ],  
    #     [ 2.3386, 0.69943, -2.4391, -1.4019, -0.80301, -1.5708 ],  
    #     [ 2.3228, 0.68866, -2.4266, -1.4036, -0.81879, -1.5708 ],  
    #     [ 2.3074, 0.67797, -2.4139, -1.4057, -0.83417, -1.5708 ],  
    #     [ 2.2925, 0.66736, -2.4008, -1.4081, -0.84913, -1.5708 ],  
    #     [ 2.2779, 0.65683, -2.3876, -1.4109, -0.86369, -1.5708 ],  
    #     [ 2.2637, 0.64637, -2.374, -1.4139, -0.87785, -1.5708 ],  
    #     [ 2.25, 0.63599, -2.3603, -1.4173, -0.89161, -1.5708 ],  
    #     [ 2.2366, 0.62567, -2.3463, -1.421, -0.90497, -1.5708 ],  
    #     [ 2.2236, 0.61541, -2.3321, -1.4249, -0.91795, -1.5708 ],  
    #     [ 2.2111, 0.60522, -2.3177, -1.4292, -0.93054, -1.5708 ],  
    #     [ 2.1988, 0.59509, -2.303, -1.4336, -0.94275, -1.5708 ],  
    #     [ 2.187, 0.58501, -2.2882, -1.4384, -0.95459, -1.5708 ],  
    #     [ 2.1755, 0.575, -2.2733, -1.4433, -0.96608, -1.5708 ],  
    #     [ 2.1644, 0.56503, -2.2581, -1.4485, -0.9772, -1.5708 ],  
    #     [ 2.1536, 0.55511, -2.2428, -1.4539, -0.98799, -1.5708 ],  
    #     [ 2.1432, 0.54524, -2.2274, -1.4595, -0.99843, -1.5708 ],  
    #     [ 2.133, 0.53542, -2.2118, -1.4652, -1.0086, -1.5708 ],  
    #     [ 2.1232, 0.52564, -2.196, -1.4712, -1.0183, -1.5708 ],  
    #     [ 2.1138, 0.51591, -2.1802, -1.4773, -1.0278, -1.5708 ],  
    #     [ 2.1046, 0.50623, -2.1642, -1.4836, -1.037, -1.5708 ],  
    #     [ 2.0957, 0.49658, -2.1482, -1.49, -1.0459, -1.5708 ],  
    #     [ 2.0871, 0.48699, -2.132, -1.4966, -1.0545, -1.5708 ],  
    #     [ 2.0788, 0.47744, -2.1158, -1.5032, -1.0628, -1.5708 ],  
    #     [ 2.0707, 0.46793, -2.0995, -1.51, -1.0709, -1.5708 ],  
    #     [ 2.0629, 0.45847, -2.0831, -1.5169, -1.0787, -1.5708 ],  
    #     [ 2.0554, 0.44906, -2.0667, -1.5239, -1.0862, -1.5708 ],  
    #     [ 2.0481, 0.4397, -2.0503, -1.531, -1.0935, -1.5708 ],  
    #     [ 2.0411, 0.43039, -2.0338, -1.5382, -1.1005, -1.5708 ],  
    #     [ 2.0343, 0.42113, -2.0173, -1.5454, -1.1073, -1.5708 ],  
    #     [ 2.0277, 0.41193, -2.0008, -1.5527, -1.1139, -1.5708 ],  
    #     [ 2.0214, 0.40279, -1.9843, -1.5601, -1.1202, -1.5708 ],  
    #     [ 2.0152, 0.3937, -1.9678, -1.5675, -1.1264, -1.5708 ],  
    #     [ 2.0093, 0.38469, -1.9514, -1.5749, -1.1323, -1.5708 ],  
    #     [ 2.0036, 0.37574, -1.935, -1.5824, -1.138, -1.5708 ],  
    #     [ 1.998, 0.36686, -1.9186, -1.5898, -1.1436, -1.5708 ],  
    #     [ 1.9927, 0.35806, -1.9023, -1.5973, -1.1489, -1.5708 ],  
    #     [ 1.9876, 0.34935, -1.8861, -1.6048, -1.154, -1.5708 ],  
    #     [ 1.9826, 0.34071, -1.87, -1.6123, -1.159, -1.5708 ],  
    #     [ 1.9778, 0.33217, -1.854, -1.6198, -1.1638, -1.5708 ],  
    #     [ 1.9732, 0.32372, -1.8381, -1.6272, -1.1684, -1.5708 ],  
    #     [ 1.9688, 0.31538, -1.8224, -1.6346, -1.1728, -1.5708 ],  
    #     [ 1.9645, 0.30714, -1.8068, -1.6419, -1.1771, -1.5708 ],  
    #     [ 1.9604, 0.29902, -1.7914, -1.6492, -1.1812, -1.5708 ],  
    #     [ 1.9564, 0.29101, -1.7761, -1.6565, -1.1852, -1.5708 ],  
    #     [ 1.9526, 0.28314, -1.7611, -1.6636, -1.189, -1.5708 ],  
    #     [ 1.949, 0.27539, -1.7463, -1.6707, -1.1926, -1.5708 ],  
    #     [ 1.9455, 0.26779, -1.7317, -1.6777, -1.1961, -1.5708 ]  ]

    # initialization
    v = []
    #theta = deepcopy (theta_tar)
    j = 1
    constraint_satisfied = False
    dir1 = abs(theta_tar[1][0]-theta_tar[0][0]) / (theta_tar[1][0]-theta_tar[0][0])
    v_max_i = []
    for i in range(6):
        v_max_i.append(dv_max)
    
    # test functions
    v.append( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] )
    theta = []
    theta.append(theta_tar[0])
    n = len(theta_tar)

    # generate velocity list
    for i in range(1, n):        
        v_new = v_from_theta(theta_tar[i-1], theta_tar[i], v[i-1])
        v.append(deepcopy(v_new))
        #print(v[i])    
    v = smooth_v(v,1)

    # recalculate angle trajectory from velocities
    for i in range(1, n):
        theta_new = theta_from_v(theta[i-1], v[i-1], v[i])
        theta.append(theta_new) 

    # check constraints
    for i in range(6):
        v_max_i.append(deepcopy(v[0][i] + dv_max))
    kg = []
    kg.append( 1 )
    kg.append( check_constraints(v[1], deepcopy(v_max_i)) )  
    for i in range(2, len(v)):
        v_max_i = []
        for j in range(6):
            v_max_i.append(deepcopy( abs(v[i][j]) + dv_max))
        kg.append( check_constraints(v[1], deepcopy(v_max_i)) ) 

    stop = time.time()

    # print results
    for i in range(n): 
        toprint = []
        for j in range(6):     
            toprint.append(theta[i][j]-theta_tar[i][j])  
        print(toprint)
        if ( kg[i]<1 ):
            print(kg[i])  

    print(dir1)     
    print(stop-start)
    for k in v:
        print(k)
